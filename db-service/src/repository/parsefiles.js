'use strict';

const fs = require('fs');
const sqlite3 = require('sqlite3').verbose();

// This function parses the attack files into sqlite db 
const parse_attacks = (dirname, db_path) => {
    return new Promise((resolve, reject) => {
        
        // check if db already exists
        if(fs.existsSync(db_path))
        {
            resolve()
        }
        
        fs.readdir(dirname, function(err, filenames) {
            if (err) {
                reject(new Error("failed to read the attacks dir"))
                return;
            }
            
            // creating the db file
            let db = new sqlite3.Database(db_path, (err) => {
                if (err) {
                    reject(new Error("failed to create the attacks db"))
                }
            });

            // creating the db table
            db.serialize(() => {
                db.each(`CREATE TABLE IF NOT EXISTS ATTACKS(NAME TEXT DEFAULT NULL,ID TEXT DEFAULT NULL,DESCRIPTION TEXT DEFAULT NULL, x_mitre_platforms TEXT DEFAULT NULL, x_mitre_detection TEXT DEFAULT NULL, phase_name TEXT DEFAULT NULL);`, (err, row) => {
                    if (err) {
                        reject(new Error("failed to create the attacks table"))
                    }
                });
            });

            // parsing every attack file
            filenames.forEach(function(filename) {

                // reading the content of the curr file
                fs.readFile(dirname + filename, 'utf-8', function(err, content) {
                    if (err) {
                        reject(new Error("failed to read the attack file: " + (dirname + filename)))
                        return;
                    }
                    
                    // parsing the content of the curr attack
                    var jsonResult = JSON.parse(content);
                    var name = jsonResult['objects']['0']['name'];
                    var description = jsonResult['objects']['0']['description'];
                    var id = jsonResult['objects']['0']['id'];
                    var platformsARR = jsonResult['objects']['0']['x_mitre_platforms'];
                    var platforms = '';
                    for (var platform in platformsARR) {
                        platforms = platforms.concat(platformsARR[platform]);
                        platforms = platforms.concat(",");
                    }
                    platforms = platforms.slice(0, -1);
                    var detection = jsonResult['objects']['0']['x_mitre_detection'];
                    var phases = (jsonResult['objects']['0']['kill_chain_phases']);
                    var phase_name = '';
                    for (var phase in phases) {
                        phase_name = phase_name.concat(phases[phase]['phase_name']);
                        phase_name = phase_name.concat(",");
                    }
                    phase_name = phase_name.slice(0, -1);
                    if (detection != undefined) {
                        detection = detection.split('"').join('');
                    } else {
                        detection = 'NA';
                    }

                    if (description != undefined) {
                        description = description.split('"').join('');
                    } else {
                        description = 'NA';
                    }
                    
                    // inserting each attack
                    db.serialize(() => {
                        db.each('INSERT INTO ATTACKS(NAME, ID, DESCRIPTION, x_mitre_platforms, x_mitre_detection, phase_name) VALUES ("' + name + '", "' + id + '", "' + description + '", "' + platforms + '", "' + detection + '", "' + phase_name + '");', (err, row) => {
                            if (err) {
                                reject(new Error("failed to insert the attack id: " + id))
                            }
                        });
                    });

                });
            });

        });
        resolve()
})
}

module.exports = Object.assign({}, {parse_attacks})