'use strict';

const fs = require('fs');
const sqlite3 = require('sqlite3').verbose();


function onError(err) {
    console.log("Exception thrown", err.message);
    process.exit(1)
}

//This function 
const readFiles = (dirname, onError) => {

    fs.readdir(dirname, function(err, filenames) {
        if (err) {
            onError(err);
            return;
        }
        
        let db = new sqlite3.Database('./server/attacks.sqlite', (err) => {
            if (err) {
                console.error(err.message);
            }
            console.log('Connected to the chinook database.');
        });

        //creating the db table
        db.serialize(() => {
            db.each(`CREATE TABLE IF NOT EXISTS ATTACKS(NAME TEXT DEFAULT NULL,ID TEXT DEFAULT NULL,DESCRIPTION TEXT DEFAULT NULL, x_mitre_platforms TEXT DEFAULT NULL, x_mitre_detection TEXT DEFAULT NULL, phase_name TEXT DEFAULT NULL);`, (err, row) => {
                if (err) {
                    console.error(err.message);
                }
            });
        });


        filenames.forEach(function(filename) {
            fs.readFile(dirname + filename, 'utf-8', function(err, content) {
                if (err) {
                    onError(err);
                    return;
                }

                var jsonResult = JSON.parse(content);
                var name = jsonResult['objects']['0']['name'];
                var description = jsonResult['objects']['0']['description'];
                var id = jsonResult['objects']['0']['id'];
                var platformsARR = jsonResult['objects']['0']['x_mitre_platforms'];
                var platforms = '';
                for (var platform in platformsARR) {
                    platforms = platforms.concat(platformsARR[platform]);
                    platforms = platforms.concat(",");
                }
                platforms = platforms.slice(0, -1);
                var detection = jsonResult['objects']['0']['x_mitre_detection'];
                var phases = (jsonResult['objects']['0']['kill_chain_phases']);
                var phase_name = '';
                for (var phase in phases) {
                    phase_name = phase_name.concat(phases[phase]['phase_name']);
                    phase_name = phase_name.concat(",");
                }
                phase_name = phase_name.slice(0, -1);
                if (detection != undefined) {
                    detection = detection.split('"').join('');
                } else {
                    detection = 'NA';
                }

                if (description != undefined) {
                    description = description.split('"').join('');
                } else {
                    description = 'NA';
                }

                db.serialize(() => {
                    db.each('INSERT INTO ATTACKS(NAME, ID, DESCRIPTION, x_mitre_platforms, x_mitre_detection, phase_name) VALUES ("' + name + '", "' + id + '", "' + description + '", "' + platforms + '", "' + detection + '", "' + phase_name + '");', (err, row) => {
                        if (err) {
                            console.log('name: ', name);
                            console.log('id: ', id);
                            console.log('description: ', description);
                            console.log('platforms: ', platforms);
                            console.log('detection: ', detection);
                            console.log('phase name: ', phase_name);
                            console.log();
                            console.log();
                            console.log();
                            console.log('INSERT INTO ATTACKS(NAME, ID, DESCRIPTION, x_mitre_platforms, x_mitre_detection, phase_name) VALUES ("' + name + '", "' + id + '", "' + description + '", "' + platforms + '", "' + detection + '", "' + phase_name + '");');
                            onError(err);
                        }
                    });
                });

            });
        });

    });
}

const testFolder = './attack/';

readFiles(testFolder, onError);